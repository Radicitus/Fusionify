{"ast":null,"code":"// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n(function (glob) {\n  var version = \"0.5.4\",\n      has = \"hasOwnProperty\",\n      separator = /[\\.\\/]/,\n      comaseparator = /\\s*,\\s*/,\n      wildcard = \"*\",\n      numsort = function numsort(a, b) {\n    return a - b;\n  },\n      current_event,\n      stop,\n      events = {\n    n: {}\n  },\n      firstDefined = function firstDefined() {\n    for (var i = 0, ii = this.length; i < ii; i++) {\n      if (typeof this[i] != \"undefined\") {\n        return this[i];\n      }\n    }\n  },\n      lastDefined = function lastDefined() {\n    var i = this.length;\n\n    while (--i) {\n      if (typeof this[i] != \"undefined\") {\n        return this[i];\n      }\n    }\n  },\n      objtos = Object.prototype.toString,\n      Str = String,\n      isArray = Array.isArray || function (ar) {\n    return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n  },\n\n  /*\\\r\n   * eve\r\n   [ method ]\r\n     * Fires event with given `name`, given scope and other parameters.\r\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\r\n   - scope (object) context for the event handlers\r\n   - varargs (...) the rest of arguments will be sent to event handlers\r\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\r\n  \\*/\n  eve = function eve(name, scope) {\n    var oldstop = stop,\n        args = Array.prototype.slice.call(arguments, 2),\n        listeners = eve.listeners(name),\n        z = 0,\n        l,\n        indexed = [],\n        queue = {},\n        out = [],\n        ce = current_event;\n    out.firstDefined = firstDefined;\n    out.lastDefined = lastDefined;\n    current_event = name;\n    stop = 0;\n\n    for (var i = 0, ii = listeners.length; i < ii; i++) {\n      if (\"zIndex\" in listeners[i]) {\n        indexed.push(listeners[i].zIndex);\n\n        if (listeners[i].zIndex < 0) {\n          queue[listeners[i].zIndex] = listeners[i];\n        }\n      }\n    }\n\n    indexed.sort(numsort);\n\n    while (indexed[z] < 0) {\n      l = queue[indexed[z++]];\n      out.push(l.apply(scope, args));\n\n      if (stop) {\n        stop = oldstop;\n        return out;\n      }\n    }\n\n    for (i = 0; i < ii; i++) {\n      l = listeners[i];\n\n      if (\"zIndex\" in l) {\n        if (l.zIndex == indexed[z]) {\n          out.push(l.apply(scope, args));\n\n          if (stop) {\n            break;\n          }\n\n          do {\n            z++;\n            l = queue[indexed[z]];\n            l && out.push(l.apply(scope, args));\n\n            if (stop) {\n              break;\n            }\n          } while (l);\n        } else {\n          queue[l.zIndex] = l;\n        }\n      } else {\n        out.push(l.apply(scope, args));\n\n        if (stop) {\n          break;\n        }\n      }\n    }\n\n    stop = oldstop;\n    current_event = ce;\n    return out;\n  }; // Undocumented. Debug only.\n\n\n  eve._events = events;\n  /*\\\r\n   * eve.listeners\r\n   [ method ]\r\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\r\n     = (array) array of event handlers\r\n  \\*/\n\n  eve.listeners = function (name) {\n    var names = isArray(name) ? name : name.split(separator),\n        e = events,\n        item,\n        items,\n        k,\n        i,\n        ii,\n        j,\n        jj,\n        nes,\n        es = [e],\n        out = [];\n\n    for (i = 0, ii = names.length; i < ii; i++) {\n      nes = [];\n\n      for (j = 0, jj = es.length; j < jj; j++) {\n        e = es[j].n;\n        items = [e[names[i]], e[wildcard]];\n        k = 2;\n\n        while (k--) {\n          item = items[k];\n\n          if (item) {\n            nes.push(item);\n            out = out.concat(item.f || []);\n          }\n        }\n      }\n\n      es = nes;\n    }\n\n    return out;\n  };\n  /*\\\r\n   * eve.separator\r\n   [ method ]\r\n     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\r\n   * here. Be aware that if you pass a string longer than one character it will be treated as\r\n   * a list of characters.\r\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\r\n  \\*/\n\n\n  eve.separator = function (sep) {\n    if (sep) {\n      sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n      sep = \"[\" + sep + \"]\";\n      separator = new RegExp(sep);\n    } else {\n      separator = /[\\.\\/]/;\n    }\n  };\n  /*\\\r\n   * eve.on\r\n   [ method ]\r\n   **\r\n   * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\r\n   | eve.on(\"*.under.*\", f);\r\n   | eve(\"mouse.under.floor\"); // triggers f\r\n   * Use @eve to trigger the listener.\r\n   **\r\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n   - f (function) event handler function\r\n   **\r\n   - name (array) if you don’t want to use separators, you can use array of strings\r\n   - f (function) event handler function\r\n   **\r\n   = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\r\n   > Example:\r\n   | eve.on(\"mouse\", eatIt)(2);\r\n   | eve.on(\"mouse\", scream);\r\n   | eve.on(\"mouse\", catchIt)(1);\r\n   * This will ensure that `catchIt` function will be called before `eatIt`.\r\n   *\r\n   * If you want to put your handler before non-indexed handlers, specify a negative value.\r\n   * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\r\n  \\*/\n\n\n  eve.on = function (name, f) {\n    if (typeof f != \"function\") {\n      return function () {};\n    }\n\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n    for (var i = 0, ii = names.length; i < ii; i++) {\n      (function (name) {\n        var names = isArray(name) ? name : Str(name).split(separator),\n            e = events,\n            exist;\n\n        for (var i = 0, ii = names.length; i < ii; i++) {\n          e = e.n;\n          e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {\n            n: {}\n          });\n        }\n\n        e.f = e.f || [];\n\n        for (i = 0, ii = e.f.length; i < ii; i++) {\n          if (e.f[i] == f) {\n            exist = true;\n            break;\n          }\n        }\n\n        !exist && e.f.push(f);\n      })(names[i]);\n    }\n\n    return function (zIndex) {\n      if (+zIndex == +zIndex) {\n        f.zIndex = +zIndex;\n      }\n    };\n  };\n  /*\\\r\n   * eve.f\r\n   [ method ]\r\n   **\r\n   * Returns function that will fire given event with optional arguments.\r\n   * Arguments that will be passed to the result function will be also\r\n   * concated to the list of final arguments.\r\n   | el.onclick = eve.f(\"click\", 1, 2);\r\n   | eve.on(\"click\", function (a, b, c) {\r\n   |     console.log(a, b, c); // 1, 2, [event object]\r\n   | });\r\n   - event (string) event name\r\n   - varargs (…) and any other arguments\r\n   = (function) possible event handler function\r\n  \\*/\n\n\n  eve.f = function (event) {\n    var attrs = [].slice.call(arguments, 1);\n    return function () {\n      eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n    };\n  };\n  /*\\\r\n   * eve.stop\r\n   [ method ]\r\n   **\r\n   * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\r\n  \\*/\n\n\n  eve.stop = function () {\n    stop = 1;\n  };\n  /*\\\r\n   * eve.nt\r\n   [ method ]\r\n   **\r\n   * Could be used inside event handler to figure out actual name of the event.\r\n   **\r\n   - subname (string) #optional subname of the event\r\n   **\r\n   = (string) name of the event, if `subname` is not specified\r\n   * or\r\n   = (boolean) `true`, if current event’s name contains `subname`\r\n  \\*/\n\n\n  eve.nt = function (subname) {\n    var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n\n    if (subname) {\n      return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n    }\n\n    return cur;\n  };\n  /*\\\r\n   * eve.nts\r\n   [ method ]\r\n   **\r\n   * Could be used inside event handler to figure out actual name of the event.\r\n   **\r\n   **\r\n   = (array) names of the event\r\n  \\*/\n\n\n  eve.nts = function () {\n    return isArray(current_event) ? current_event : current_event.split(separator);\n  };\n  /*\\\r\n   * eve.off\r\n   [ method ]\r\n   **\r\n   * Removes given function from the list of event listeners assigned to given name.\r\n   * If no arguments specified all the events will be cleared.\r\n   **\r\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n   - f (function) event handler function\r\n  \\*/\n\n  /*\\\r\n   * eve.unbind\r\n   [ method ]\r\n   **\r\n   * See @eve.off\r\n  \\*/\n\n\n  eve.off = eve.unbind = function (name, f) {\n    if (!name) {\n      eve._events = events = {\n        n: {}\n      };\n      return;\n    }\n\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n    if (names.length > 1) {\n      for (var i = 0, ii = names.length; i < ii; i++) {\n        eve.off(names[i], f);\n      }\n\n      return;\n    }\n\n    names = isArray(name) ? name : Str(name).split(separator);\n    var e,\n        key,\n        splice,\n        i,\n        ii,\n        j,\n        jj,\n        cur = [events],\n        inodes = [];\n\n    for (i = 0, ii = names.length; i < ii; i++) {\n      for (j = 0; j < cur.length; j += splice.length - 2) {\n        splice = [j, 1];\n        e = cur[j].n;\n\n        if (names[i] != wildcard) {\n          if (e[names[i]]) {\n            splice.push(e[names[i]]);\n            inodes.unshift({\n              n: e,\n              name: names[i]\n            });\n          }\n        } else {\n          for (key in e) {\n            if (e[has](key)) {\n              splice.push(e[key]);\n              inodes.unshift({\n                n: e,\n                name: key\n              });\n            }\n          }\n        }\n\n        cur.splice.apply(cur, splice);\n      }\n    }\n\n    for (i = 0, ii = cur.length; i < ii; i++) {\n      e = cur[i];\n\n      while (e.n) {\n        if (f) {\n          if (e.f) {\n            for (j = 0, jj = e.f.length; j < jj; j++) {\n              if (e.f[j] == f) {\n                e.f.splice(j, 1);\n                break;\n              }\n            }\n\n            !e.f.length && delete e.f;\n          }\n\n          for (key in e.n) {\n            if (e.n[has](key) && e.n[key].f) {\n              var funcs = e.n[key].f;\n\n              for (j = 0, jj = funcs.length; j < jj; j++) {\n                if (funcs[j] == f) {\n                  funcs.splice(j, 1);\n                  break;\n                }\n              }\n\n              !funcs.length && delete e.n[key].f;\n            }\n          }\n        } else {\n          delete e.f;\n\n          for (key in e.n) {\n            if (e.n[has](key) && e.n[key].f) {\n              delete e.n[key].f;\n            }\n          }\n        }\n\n        e = e.n;\n      }\n    } // prune inner nodes in path\n\n\n    prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n      e = inodes[i];\n\n      for (key in e.n[e.name].f) {\n        // not empty (has listeners)\n        continue prune;\n      }\n\n      for (key in e.n[e.name].n) {\n        // not empty (has children)\n        continue prune;\n      } // is empty\n\n\n      delete e.n[e.name];\n    }\n  };\n  /*\\\r\n   * eve.once\r\n   [ method ]\r\n   **\r\n   * Binds given event handler with a given name to only run once then unbind itself.\r\n   | eve.once(\"login\", f);\r\n   | eve(\"login\"); // triggers f\r\n   | eve(\"login\"); // no listeners\r\n   * Use @eve to trigger the listener.\r\n   **\r\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n   - f (function) event handler function\r\n   **\r\n   = (function) same return function as @eve.on\r\n  \\*/\n\n\n  eve.once = function (name, f) {\n    var f2 = function f2() {\n      eve.off(name, f2);\n      return f.apply(this, arguments);\n    };\n\n    return eve.on(name, f2);\n  };\n  /*\\\r\n   * eve.version\r\n   [ property (string) ]\r\n   **\r\n   * Current version of the library.\r\n  \\*/\n\n\n  eve.version = version;\n\n  eve.toString = function () {\n    return \"You are running Eve \" + version;\n  };\n\n  glob.eve = eve;\n  typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () {\n    return eve;\n  }) : glob.eve = eve;\n})(typeof window != \"undefined\" ? window : this);","map":{"version":3,"sources":["C:/Users/lawdi/Desktop/Projects/Fusionify/Fusionify/Frontend/web/node_modules/eve/eve.js"],"names":["glob","version","has","separator","comaseparator","wildcard","numsort","a","b","current_event","stop","events","n","firstDefined","i","ii","length","lastDefined","objtos","Object","prototype","toString","Str","String","isArray","Array","ar","call","eve","name","scope","oldstop","args","slice","arguments","listeners","z","l","indexed","queue","out","ce","push","zIndex","sort","apply","_events","names","split","e","item","items","k","j","jj","nes","es","concat","f","sep","replace","RegExp","on","exist","hasOwnProperty","event","attrs","nt","subname","cur","join","test","nts","off","unbind","key","splice","inodes","unshift","funcs","prune","once","f2","module","exports","define","amd","window"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// ┌────────────────────────────────────────────────────────────┐ \\\\\r\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\r\n// ├────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\r\n// └────────────────────────────────────────────────────────────┘ \\\\\r\n\r\n(function (glob) {\r\n    var version = \"0.5.4\",\r\n        has = \"hasOwnProperty\",\r\n        separator = /[\\.\\/]/,\r\n        comaseparator = /\\s*,\\s*/,\r\n        wildcard = \"*\",\r\n        numsort = function (a, b) {\r\n            return a - b;\r\n        },\r\n        current_event,\r\n        stop,\r\n        events = {n: {}},\r\n        firstDefined = function () {\r\n            for (var i = 0, ii = this.length; i < ii; i++) {\r\n                if (typeof this[i] != \"undefined\") {\r\n                    return this[i];\r\n                }\r\n            }\r\n        },\r\n        lastDefined = function () {\r\n            var i = this.length;\r\n            while (--i) {\r\n                if (typeof this[i] != \"undefined\") {\r\n                    return this[i];\r\n                }\r\n            }\r\n        },\r\n        objtos = Object.prototype.toString,\r\n        Str = String,\r\n        isArray = Array.isArray || function (ar) {\r\n            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\r\n        },\r\n    /*\\\r\n     * eve\r\n     [ method ]\r\n\r\n     * Fires event with given `name`, given scope and other parameters.\r\n\r\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\r\n     - scope (object) context for the event handlers\r\n     - varargs (...) the rest of arguments will be sent to event handlers\r\n\r\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\r\n    \\*/\r\n        eve = function (name, scope) {\r\n            var oldstop = stop,\r\n                args = Array.prototype.slice.call(arguments, 2),\r\n                listeners = eve.listeners(name),\r\n                z = 0,\r\n                l,\r\n                indexed = [],\r\n                queue = {},\r\n                out = [],\r\n                ce = current_event;\r\n            out.firstDefined = firstDefined;\r\n            out.lastDefined = lastDefined;\r\n            current_event = name;\r\n            stop = 0;\r\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\r\n                indexed.push(listeners[i].zIndex);\r\n                if (listeners[i].zIndex < 0) {\r\n                    queue[listeners[i].zIndex] = listeners[i];\r\n                }\r\n            }\r\n            indexed.sort(numsort);\r\n            while (indexed[z] < 0) {\r\n                l = queue[indexed[z++]];\r\n                out.push(l.apply(scope, args));\r\n                if (stop) {\r\n                    stop = oldstop;\r\n                    return out;\r\n                }\r\n            }\r\n            for (i = 0; i < ii; i++) {\r\n                l = listeners[i];\r\n                if (\"zIndex\" in l) {\r\n                    if (l.zIndex == indexed[z]) {\r\n                        out.push(l.apply(scope, args));\r\n                        if (stop) {\r\n                            break;\r\n                        }\r\n                        do {\r\n                            z++;\r\n                            l = queue[indexed[z]];\r\n                            l && out.push(l.apply(scope, args));\r\n                            if (stop) {\r\n                                break;\r\n                            }\r\n                        } while (l)\r\n                    } else {\r\n                        queue[l.zIndex] = l;\r\n                    }\r\n                } else {\r\n                    out.push(l.apply(scope, args));\r\n                    if (stop) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            stop = oldstop;\r\n            current_event = ce;\r\n            return out;\r\n        };\r\n    // Undocumented. Debug only.\r\n    eve._events = events;\r\n    /*\\\r\n     * eve.listeners\r\n     [ method ]\r\n\r\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\r\n\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\r\n\r\n     = (array) array of event handlers\r\n    \\*/\r\n    eve.listeners = function (name) {\r\n        var names = isArray(name) ? name : name.split(separator),\r\n            e = events,\r\n            item,\r\n            items,\r\n            k,\r\n            i,\r\n            ii,\r\n            j,\r\n            jj,\r\n            nes,\r\n            es = [e],\r\n            out = [];\r\n        for (i = 0, ii = names.length; i < ii; i++) {\r\n            nes = [];\r\n            for (j = 0, jj = es.length; j < jj; j++) {\r\n                e = es[j].n;\r\n                items = [e[names[i]], e[wildcard]];\r\n                k = 2;\r\n                while (k--) {\r\n                    item = items[k];\r\n                    if (item) {\r\n                        nes.push(item);\r\n                        out = out.concat(item.f || []);\r\n                    }\r\n                }\r\n            }\r\n            es = nes;\r\n        }\r\n        return out;\r\n    };\r\n    /*\\\r\n     * eve.separator\r\n     [ method ]\r\n\r\n     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\r\n     * here. Be aware that if you pass a string longer than one character it will be treated as\r\n     * a list of characters.\r\n\r\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\r\n    \\*/\r\n    eve.separator = function (sep) {\r\n        if (sep) {\r\n            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\r\n            sep = \"[\" + sep + \"]\";\r\n            separator = new RegExp(sep);\r\n        } else {\r\n            separator = /[\\.\\/]/;\r\n        }\r\n    };\r\n    /*\\\r\n     * eve.on\r\n     [ method ]\r\n     **\r\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\r\n     | eve.on(\"*.under.*\", f);\r\n     | eve(\"mouse.under.floor\"); // triggers f\r\n     * Use @eve to trigger the listener.\r\n     **\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n     - f (function) event handler function\r\n     **\r\n     - name (array) if you don’t want to use separators, you can use array of strings\r\n     - f (function) event handler function\r\n     **\r\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\r\n     > Example:\r\n     | eve.on(\"mouse\", eatIt)(2);\r\n     | eve.on(\"mouse\", scream);\r\n     | eve.on(\"mouse\", catchIt)(1);\r\n     * This will ensure that `catchIt` function will be called before `eatIt`.\r\n     *\r\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\r\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\r\n    \\*/\r\n    eve.on = function (name, f) {\r\n        if (typeof f != \"function\") {\r\n            return function () {};\r\n        }\r\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\r\n        for (var i = 0, ii = names.length; i < ii; i++) {\r\n            (function (name) {\r\n                var names = isArray(name) ? name : Str(name).split(separator),\r\n                    e = events,\r\n                    exist;\r\n                for (var i = 0, ii = names.length; i < ii; i++) {\r\n                    e = e.n;\r\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\r\n                }\r\n                e.f = e.f || [];\r\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\r\n                    exist = true;\r\n                    break;\r\n                }\r\n                !exist && e.f.push(f);\r\n            }(names[i]));\r\n        }\r\n        return function (zIndex) {\r\n            if (+zIndex == +zIndex) {\r\n                f.zIndex = +zIndex;\r\n            }\r\n        };\r\n    };\r\n    /*\\\r\n     * eve.f\r\n     [ method ]\r\n     **\r\n     * Returns function that will fire given event with optional arguments.\r\n     * Arguments that will be passed to the result function will be also\r\n     * concated to the list of final arguments.\r\n     | el.onclick = eve.f(\"click\", 1, 2);\r\n     | eve.on(\"click\", function (a, b, c) {\r\n     |     console.log(a, b, c); // 1, 2, [event object]\r\n     | });\r\n     - event (string) event name\r\n     - varargs (…) and any other arguments\r\n     = (function) possible event handler function\r\n    \\*/\r\n    eve.f = function (event) {\r\n        var attrs = [].slice.call(arguments, 1);\r\n        return function () {\r\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\r\n        };\r\n    };\r\n    /*\\\r\n     * eve.stop\r\n     [ method ]\r\n     **\r\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\r\n    \\*/\r\n    eve.stop = function () {\r\n        stop = 1;\r\n    };\r\n    /*\\\r\n     * eve.nt\r\n     [ method ]\r\n     **\r\n     * Could be used inside event handler to figure out actual name of the event.\r\n     **\r\n     - subname (string) #optional subname of the event\r\n     **\r\n     = (string) name of the event, if `subname` is not specified\r\n     * or\r\n     = (boolean) `true`, if current event’s name contains `subname`\r\n    \\*/\r\n    eve.nt = function (subname) {\r\n        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\r\n        if (subname) {\r\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\r\n        }\r\n        return cur;\r\n    };\r\n    /*\\\r\n     * eve.nts\r\n     [ method ]\r\n     **\r\n     * Could be used inside event handler to figure out actual name of the event.\r\n     **\r\n     **\r\n     = (array) names of the event\r\n    \\*/\r\n    eve.nts = function () {\r\n        return isArray(current_event) ? current_event : current_event.split(separator);\r\n    };\r\n    /*\\\r\n     * eve.off\r\n     [ method ]\r\n     **\r\n     * Removes given function from the list of event listeners assigned to given name.\r\n     * If no arguments specified all the events will be cleared.\r\n     **\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n     - f (function) event handler function\r\n    \\*/\r\n    /*\\\r\n     * eve.unbind\r\n     [ method ]\r\n     **\r\n     * See @eve.off\r\n    \\*/\r\n    eve.off = eve.unbind = function (name, f) {\r\n        if (!name) {\r\n            eve._events = events = {n: {}};\r\n            return;\r\n        }\r\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\r\n        if (names.length > 1) {\r\n            for (var i = 0, ii = names.length; i < ii; i++) {\r\n                eve.off(names[i], f);\r\n            }\r\n            return;\r\n        }\r\n        names = isArray(name) ? name : Str(name).split(separator);\r\n        var e,\r\n            key,\r\n            splice,\r\n            i, ii, j, jj,\r\n            cur = [events],\r\n            inodes = [];\r\n        for (i = 0, ii = names.length; i < ii; i++) {\r\n            for (j = 0; j < cur.length; j += splice.length - 2) {\r\n                splice = [j, 1];\r\n                e = cur[j].n;\r\n                if (names[i] != wildcard) {\r\n                    if (e[names[i]]) {\r\n                        splice.push(e[names[i]]);\r\n                        inodes.unshift({\r\n                            n: e,\r\n                            name: names[i]\r\n                        });\r\n                    }\r\n                } else {\r\n                    for (key in e) if (e[has](key)) {\r\n                        splice.push(e[key]);\r\n                        inodes.unshift({\r\n                            n: e,\r\n                            name: key\r\n                        });\r\n                    }\r\n                }\r\n                cur.splice.apply(cur, splice);\r\n            }\r\n        }\r\n        for (i = 0, ii = cur.length; i < ii; i++) {\r\n            e = cur[i];\r\n            while (e.n) {\r\n                if (f) {\r\n                    if (e.f) {\r\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\r\n                            e.f.splice(j, 1);\r\n                            break;\r\n                        }\r\n                        !e.f.length && delete e.f;\r\n                    }\r\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\r\n                        var funcs = e.n[key].f;\r\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\r\n                            funcs.splice(j, 1);\r\n                            break;\r\n                        }\r\n                        !funcs.length && delete e.n[key].f;\r\n                    }\r\n                } else {\r\n                    delete e.f;\r\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\r\n                        delete e.n[key].f;\r\n                    }\r\n                }\r\n                e = e.n;\r\n            }\r\n        }\r\n        // prune inner nodes in path\r\n        prune: for (i = 0, ii = inodes.length; i < ii; i++) {\r\n            e = inodes[i];\r\n            for (key in e.n[e.name].f) {\r\n                // not empty (has listeners)\r\n                continue prune;\r\n            }\r\n            for (key in e.n[e.name].n) {\r\n                // not empty (has children)\r\n                continue prune;\r\n            }\r\n            // is empty\r\n            delete e.n[e.name];\r\n        }\r\n    };\r\n    /*\\\r\n     * eve.once\r\n     [ method ]\r\n     **\r\n     * Binds given event handler with a given name to only run once then unbind itself.\r\n     | eve.once(\"login\", f);\r\n     | eve(\"login\"); // triggers f\r\n     | eve(\"login\"); // no listeners\r\n     * Use @eve to trigger the listener.\r\n     **\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n     - f (function) event handler function\r\n     **\r\n     = (function) same return function as @eve.on\r\n    \\*/\r\n    eve.once = function (name, f) {\r\n        var f2 = function () {\r\n            eve.off(name, f2);\r\n            return f.apply(this, arguments);\r\n        };\r\n        return eve.on(name, f2);\r\n    };\r\n    /*\\\r\n     * eve.version\r\n     [ property (string) ]\r\n     **\r\n     * Current version of the library.\r\n    \\*/\r\n    eve.version = version;\r\n    eve.toString = function () {\r\n        return \"You are running Eve \" + version;\r\n    };\r\n    glob.eve = eve;\r\n    typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () { return eve; }) : glob.eve = eve;\r\n})(typeof window != \"undefined\" ? window : this);\r\n"]},"metadata":{},"sourceType":"script"}